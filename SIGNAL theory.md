## Can you explain the concept of signals in programming? How are they used in Unix like operating systems?
```c
Definition:
A signal is a limited form of inter-process communication (IPC) in Unix-like operating systems.
It is used to notify a process that a specific event has occurred.
How Signals Work:
    A signal is sent to a process (via kill(), raise(), or by the kernel).
    The process can either:
    Handle it with a signal handler (a user-defined function),
    Ignore it, or
     Use the default action (terminate, stop, etc.).
 Common Uses:

 Signal        Purpose                       Default Action          
 ---------  ----------------------------  ----------------------- 
 `SIGINT`   Ctrl+C in terminal            Terminate process       
 `SIGKILL`  Forcefully kill process       Terminate (can’t catch) 
 `SIGTERM`  Graceful termination request  Terminate               
 `SIGCHLD`  Child process exited          Ignore or handle        
 `SIGSTOP`  Pause execution               Stop (can’t catch)      
 `SIGCONT`  Continue execution            Resume                  
 `SIGSEGV`  Invalid memory access         Terminate (core dump)   
Functions Used:
     signal(signum, handler) – Set a handler.
      sigaction() – More robust way to handle signals.
      raise(signum) – Send a signal to self.
      kill(pid, signum) – Send signal to another process.
```
## What are software interrupts and hardware interrupts and mention potential issues when dealing with them?
```c
Software Interrupts:
Generated by programs or operating system (e.g., signals).
Examples: SIGINT, SIGSEGV, raise(), kill()
Used for process control, IPC, exception handling.
Hardware Interrupts:
Triggered by hardware devices to gain CPU attention.
Examples: Keyboard press, timer overflow, disk I/O complete.
Handled by the Interrupt Service Routine (ISR) in kernel.

Potential Issues:
   Issue                  Description                                                                                        
 ---------------------  -------------------------------------------------------------------------------------------------- 
 **Race Conditions**    Multiple interrupts/signals arriving simultaneously can cause unpredictable behavior.              
 **Signal Reentrancy**  A signal handler interrupting itself if not handled properly (solve with `sigaction()` and flags). 
 **Missed Signals**     If not masked or handled, important signals can be missed.                                         
 **Interrupt Storms**   Too many hardware interrupts causing CPU overload.                                                 

```
## What is synchronous signal and asynchronous signal and how the process can be used for both?
```c
Synchronous Signals:
Generated as a direct result of process execution.
Tied to a specific instruction.
Examples:
SIGFPE (divide by zero)
SIGSEGV (invalid memory access)
Always sent to the process that caused them.
Usually result in immediate crash unless handled.

Asynchronous Signals:
Generated externally to the process.
Can occur at any point in execution.
Examples:
SIGINT (Ctrl+C)
SIGTERM (sent by kill)
SIGCHLD (sent when child exits)

How a Process Can Handle Both:
Use signal() or sigaction() to register a handler.
Inside the handler, determine the signal type and take action.
Use sigprocmask() to block/unblock signals during critical sections to avoid race conditions.
```
## Who is responsible for generating signals?
```c
Signals can be generated by:
The kernel — on specific events (e.g., SIGSEGV on invalid memory access, SIGCHLD when a child terminates).
The user — using terminal commands (e.g., Ctrl+C sends SIGINT).
Processes — using system calls like kill() or raise() to send signals to themselves or other processes.
Hardware — indirectly, by triggering exceptions that the OS converts into signals (e.g., divide by zero → SIGFPE).

```
## What is signal handler?
```c
A signal handler is a function defined by the programmer to override
 the default action taken when a specific signal is received.

void handle_sigint(int sig) {
    printf("Caught SIGINT (signal %d)\n", sig);
}

signal(SIGINT, handle_sigint);  // Register the handler

When the process receives SIGINT (Ctrl+C), handle_sigint() will be called instead of the default termination.
```

## Which system call is used to send a signal to the process?
```c
kill(pid_t pid, int sig)
Sends the signal sig to the process with ID pid.
Example: kill(1234, SIGTERM); sends SIGTERM to process 1234.
Note: Despite its name, kill() doesn’t always kill the process — it just sends a signal.

```
## Write a program to send a signal to itself (same process)?
```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void handler(int sig) {
    printf("Signal %d received by self\n", sig);
}

int main() {
    signal(SIGUSR1, handler);  // Set up custom handler
    raise(SIGUSR1);            // Send signal to self
    return 0;
}
```

## Explain the default action associated with the SIGKILL signal?
```c
SIGKILL (signal number 9) forcibly terminates a process immediately.
It cannot be caught, blocked, or ignored.
Used when a process must be killed unconditionally (e.g., kill -9 <pid>).
The OS immediately reclaims resources used by the process.
```
## How does a process handle a signal while it is executing in kernel mode?
```c
If a signal is delivered while the process is in kernel mode, the signal is not handled immediately.
The kernel defers signal delivery until the process returns to user mode.
This avoids interrupting critical kernel operations.
```
## Describe the behaviour of a process when it receives a SIGSEGV signal?
```c
SIGSEGV (Segmentation Fault) occurs when a process accesses invalid memory.
Default behavior: The process is terminated and usually a core dump is generated for debugging.
Can be handled using a custom signal handler, but it’s dangerous to recover from it without corrupting memory.
```

## What is the role of the sigwait() function in signal handling?
```c
sigwait() is used to synchronously wait for a signal in a multithreaded program.
It allows a thread to pause execution until a specific signal arrives.

sigset_t set;
int sig;
sigemptyset(&set);
sigaddset(&set, SIGUSR1);
pthread_sigmask(SIG_BLOCK, &set, NULL);
sigwait(&set, &sig);  // Wait for SIGUSR1

Advantages:

More controlled and thread-safe than signal() or sigaction()
Avoids race conditions in signal delivery

```
### Explain the concept of signal correlation in a distributed environment?
```c
In a distributed environment, signal correlation refers to:
Matching signals/events (e.g., errors, status updates, triggers) generated across multiple nodes/processes.
It ensures that events from various sources are associated with the correct process instance, session, or transaction.

Use case:

In a microservices-based system, if one service crashes and sends a failure notification,
another service may receive a signal or message to rollback a transaction.
Correlation ensures that the signal is handled in the correct context.
```
## Explain how a process handles a signal while it is in the ready state?
```c
If a process is in the ready state (waiting to be scheduled), the kernel delays signal delivery.
The signal is recorded (marked as pending).
Once the process gets CPU and switches to running state,
the signal is then delivered and the corresponding handler is executed before resuming normal execution.

## What is the role of the sigqueue() function in signal handling?

sigqueue(pid, signo, value) allows sending a signal with an attached value (data) to another process.
It's part of the POSIX real-time signals API.

union sigval val;
val.sival_int = 42;
sigqueue(pid, SIGUSR1, val);

In the receiver:

void handler(int sig, siginfo_t *info, void *context) {
    printf("Received value: %d\n", info->si_value.sival_int);
}
 Unlike kill(), it supports custom data transfer with the signal.

```
## Describe the interaction between signals and IPC mechanisms in Unix-like systems?
```c
Signals are not data-transfer mechanisms like pipes or shared memory.
But they are often used in combination with IPC for:
Notification that data is available (e.g., SIGIO for I/O readiness).
Synchronization (e.g., SIGCHLD tells parent process that child has exited, triggering wait()).
Error reporting across processes using kill() or sigqueue().
  Example: A producer sends data through a pipe and then sends SIGUSR1 to the consumer to notify that data is ready.

```
## Explain how a process can determine the priority of a received signal?
```c
signals do not have built-in numeric priority in standard Unix.
But signals are handled in order of signal number (lower-numbered signals are often delivered first if pending).
Real-time signals (e.g., SIGRTMIN to SIGRTMAX) are:
Queued (not overwritten).
Delivered in order of arrival.
May be assigned application-defined priority using sigqueue() or signal numbering.
```

## What is the role of the sigaltstack() function in signal handling?
```c
sigaltstack() allows defining an alternate stack for executing signal handlers.
Useful in cases where the main stack is corrupted (e.g., SIGSEGV, stack overflow).
stack_t ss;
ss.ss_sp = malloc(SIGSTKSZ);
ss.ss_size = SIGSTKSZ;
ss.ss_flags = 0;
sigaltstack(&ss, NULL);
Then set SA_ONSTACK in sigaction() to use the alternate stack.
```

## Explain how a process can determine whether a signal was sent by the kernel or another process?
```c
In a signal handler using sigaction() with SA_SIGINFO, the siginfo_t structure contains:

si_pid – the PID of the sending process.
si_code – the origin code:
SI_USER – signal from a user process.
SI_KERNEL – signal sent by the kernel (e.g., SIGSEGV).
SI_QUEUE – from sigqueue().
SI_TIMER, SI_ASYNCIO, etc.

```
## Describe the interaction between signals and system calls in Unix-like systems?
```c
If a signal is delivered while a blocking system call is running (like read(), sleep(), wait()), the system call may:
Return early with EINTR (interrupted).
Restart automatically if the SA_RESTART flag is set in sigaction().

int fd = open("file.txt", O_RDONLY);
read(fd, buf, 100);  // May be interrupted by signal

If interrupted by a signal like SIGINT, read() returns -1 and sets errno = EINTR
```
## How does a process handle a signal while it is waiting for a semaphore?
```c
If a process is blocked on a semaphore (semop(), sem_wait()), a signal can interrupt the wait.
If the signal has a handler, and no SA_RESTART flag is set, the semaphore call returns -1 and errno is set to EINTR.
The signal handler is executed, and the process can choose to:
         Retry the semaphore.
             Abort.
          Handle it differently.
```
## Describe the difference between a signal handler and a signal mask?
```c
   Aspect             Signal Handler                             Signal Mask                                    
 -----------------  -----------------------------------------  ---------------------------------------------- 
 **Definition**     Function called when a signal is received     Bitmask that defines which signals are blocked 
 **Purpose**        Executes custom logic for a signal            Temporarily blocks signals during execution    
 **Function Used**  `signal()`, `sigaction()`                     `sigprocmask()`, `pthread_sigmask()`           

```
## How does a process handle a signal while it is in the zombie state?
```c
A zombie process has already terminated, and is not running, only its exit status is held by the kernel for the parent.
Since it's no longer active, it cannot handle any signals.
Only the parent process can receive SIGCHLD to clean up the zombie using wait() or waitpid().
```

## What are the advantages and disadvantages of using signals for interprocess communication?
```c
Advantages:

Lightweight and fast.
Useful for asynchronous event notification.
Don’t require shared memory or file descriptors.

❌ Disadvantages:

Limited information can be transferred (except with sigqueue()).
Risk of race conditions.
Non-deterministic delivery.
Signal handlers have restrictions (e.g., async-signal-safe functions only).
```
### Explain how a process handles a signal while it is in a sleep state.
```c
If a process is in a sleeping or blocking system call (read(), sleep(), pause()):
The signal wakes it up.
If a handler is defined, it is called.
If not, the default action is performed.
After handling, the system call may return EINTR or restart (if SA_RESTART is used).
```
## How does a process handle a signal while it is in a critical section?
```c
A signal may interrupt the process in the middle of critical code.
If the signal handler modifies shared resources, it can cause inconsistent state.
Best Practice:
Block signals during critical sections using sigprocmask() or sigsetjmp()/siglongjmp() for controlled flow.

```
## What are some of the challenges associated with signal handling in multi-threaded programs?
```c
Signals are delivered to one thread only, making predictability hard.
All threads share signal handlers but may have different signal masks.
Requires careful use of:
             sigwait() for deterministic handling
             pthread_kill() to target specific threads
Risk of deadlocks, reentrancy issues, and race conditions if not properly synchronized.
```
## What is a race condition? Explain how it might occur in the context of signals?
```c
A race condition occurs when multiple threads/processes access shared data and the final result depends on the order of execution.
In Signals:
If a signal handler modifies shared state or global variables without synchronization,
and is triggered during modification, inconsistent results or crashes may occur.
volatile int counter;
void handler(int sig) { counter++; }  // race if main also modifies counter
```
### Discuss how a deadlock situation can be caused or resolved by signal handling?
```c
Deadlock Caused By Signals:
If a signal handler tries to acquire a mutex or semaphore already held by the interrupted code,
 it can cause self-deadlock.
Deadlock Resolved Using Signals:
A signal (e.g., SIGALRM) can be used to interrupt a blocked process
(e.g., hung on I/O or waiting on resource) and force cleanup or timeout logic.

```
## How can you use signals to force a process to dump core?
```c
Sending SIGSEGV, SIGABRT, or SIGFPE can make a process crash and produce a core dump (if enabled via ulimit -c unlimited).
abort() is commonly used to send SIGABRT for this purpose.
```
## What are the implications of using longjmp() and setjmp() in signal handlers?
```c
setjmp() saves the current execution context.
longjmp() restores it, even from within a signal handler.

Risks:

Can bypass cleanup code, unlocking, or finally-style operations.
Must be careful to only use async-signal-safe functions after jumping.
Often replaced by sigsetjmp() / siglongjmp() which also save the signal mask.
```
### Difference between termination and suspending of a signal
```c
 **Termination**                             **Suspending**                              
 ------------------------------------------  ------------------------------------------- 
 Ends the process completely                 Temporarily stops the process               
 Signal example: `SIGKILL`, `SIGTERM`        Signal example: `SIGSTOP`                   
 Resources are released                      Resources are held in memory                
 Can be caught (except `SIGKILL`)            Cannot be caught (`SIGSTOP` is uncatchable) 
 Process enters **terminated/zombie** state  Process enters **stopped** state            
```
### How CPU access the device register?
```c
Device registers are memory-mapped I/O or port-mapped I/O.
The CPU uses specific I/O instructions (in, out on x86, or memory load/store) to read/write device registers.
The device registers are mapped to physical memory addresses, and the OS knows the base address for each device.
```
## what is IRQ line?
```c
IRQ (Interrupt Request) line is a hardware signal line over which a device notifies the CPU that it needs attention.
Each device is assigned an IRQ number (line) to communicate with the CPU via interrupts.
```

### How do you find out unique value for each IRQ line?
```c
The IRQ number is typically assigned by the hardware/BIOS.
You can find IRQ numbers:
In Linux: cat /proc/interrupts
Using: lscpu, lshw, or lspci
IRQ lines must be unique per device unless shared interrupts are supported.
```
### when interrupt occurs?
```c
An interrupt occurs when:
An I/O device needs CPU attention (keyboard, mouse, network).
A timer expires.
A system event happens that needs immediate handling.
Software or kernel raises an interrupt request (software interrupt).
```
### when are exceptions when they occur?
```c
Exceptions are CPU-generated signals in response to errors or special conditions during execution.
 Exception Type      Trigger                                  
 ------------------  ---------------------------------------- 
 Divide-by-zero      Division instruction with zero divisor   
 Page fault          Accessing unmapped memory                
 General protection  Invalid segment access                   
 Invalid opcode      Executing an unknown machine instruction 
Exceptions can be synchronous (predictable) and are handled by exception handlers in the kernel.
```


### How does kernel informs to the parent that it(child) process is terminated?
```c
The kernel sends the SIGCHLD signal to the parent process when the child terminates.
The parent must call wait() or waitpid() to read the child's exit status.
This avoids zombie processes.
```
### Which member of PCB contains the information about the signals?
```c
The PCB (Process Control Block) stores:
Pending signal list
Signal mask (blocked signals)
Signal disposition table (handlers)
In Linux, this is part of the struct task_struct under members like:
           sigpending
            blocked
            sighand
```
## How can we replace SIGDEL with SIGIN
```c
There is no SIGDEL in POSIX signals. Possibly a typo.
To change signal behavior, simply reassign the handler for SIGINT (or any signal):
signal(SIGINT, new_handler);
If you're referring to changing signal numbers or semantics:
you cannot rename signals, but you can override behavior via custom handlers.

```
## How do you modify signal behaviour table/signal disposition
```c
Use signal() or sigaction() system calls to set new handlers or ignore signals:
// Old method
signal(SIGINT, handler_function);

// Modern method
struct sigaction sa;
sa.sa_handler = handler_function;
sigemptyset(&sa.sa_mask);
sa.sa_flags = 0;
sigaction(SIGINT, &sa, NULL);
This updates the signal disposition table in the process's control block.
```

## why crash in program occurs?
```c
Crashes are usually caused by:
Segmentation faults (SIGSEGV) – accessing invalid memory.
Illegal instructions (SIGILL).
Abort (SIGABRT) – failed assertions.
Divide by zero (SIGFPE).
Stack overflows, buffer overflows, race conditions, etc.
The OS sends a signal and the program terminates, often with a core dump.
```
### How do you install signal handler in signal disposition table from user space?
```c
Using signal() or sigaction() from a C program:
#include <signal.h>
#include <stdio.h>

void handler(int sig) {
    printf("Caught signal %d\n", sig);
}

int main() {
    signal(SIGINT, handler);  // Install user-space signal handler
    while (1);
}
```
### How do you catch signal?
```c
Register a custom signal handler using:
signal() — simple interface
sigaction() — advanced, POSIX-compliant and preferred
void handler(int sig) {
    printf("Caught signal %d\n", sig);
}

int main() {
    signal(SIGINT, handler);  // Catch Ctrl+C
    while (1);
}
You can also catch multiple signals and take different actions based on the signal number inside the handler.
```
### What does header file contains?
```c
A header file (.h) in C contains:
Function declarations
Macros and constants
Data type definitions (struct, enum, typedef)
Inline functions
Global variable declarations (rarely recommended)
Examples:
<signal.h> – signal functions/macros
<stdio.h> – I/O functions like printf, scanf
<unistd.h> – system calls like fork, exec, sleep

```
### How do you clear the content of sa_mask?
```c
To clear all signals from a signal mask:
sigemptyset(&sa.sa_mask);
This ensures no additional signals are blocked during handler execution.
```
### Why signals are needed to be blocked?
```c
Signals are blocked to:
Prevent interruption of critical sections
Avoid race conditions
Ensure atomic operations complete before handling signals
Temporarily delay signal handling until a safe point
Blocked signals are queued as pending until unblocked.
```
### Signal no 2's corresponding bit is set to 1? what do you meant by it?
```c
Signal number 2 is SIGINT (typically Ctrl+C).
In a signal mask or pending signal set, if bit 2 is set to 1:
It means SIGINT is either blocked or pending.
The bit positions map directly to signal numbers:
0000 0100  // signal number 2 = bit 2 = SIGINT
```
## How can we see the blocking signal information in PC?
```c
You can see blocked signals using:
cat /proc/<pid>/status | grep SigBlk
Output like SigBlk: 0000000000000004 indicates signal 2 (SIGINT) is blocked.
sigset_t set;
sigprocmask(0, NULL, &set);

```
### How do I get access to some inf0ormation present in kernel space?
```c
From user space, kernel space is protected. You can access some parts safely via:

/proc filesystem (virtual view of kernel)
System calls (getpid(), uname(), readlink() etc.)
ioctl() or sysfs interfaces for devices
ptrace() for debugging
/dev/kmem or /dev/mem (low-level, root-only, dangerous)
Direct access is not allowed for safety/stability.
```
### During the execution of signal handler, other than default signal. Can you block additional signal?
```c
You can block additional signals temporarily during the handler execution using sa_mask:
sa.sa_handler = myhandler;
sigemptyset(&sa.sa_mask);
sigaddset(&sa.sa_mask, SIGTERM);  // Block SIGTERM during handler
sigaction(SIGINT, &sa, NULL);
This blocks SIGTERM while SIGINT is being handled.
```

### Explain the scenario where signal is blocked?
```c
You're modifying a shared variable in your program and you don’t want a signal to interrupt midway:

sigset_t block_set, old_set;
sigemptyset(&block_set);
sigaddset(&block_set, SIGINT);

// Block SIGINT temporarily
sigprocmask(SIG_BLOCK, &block_set, &old_set);
// Critical section
counter++;
// Restore original mask
sigprocmask(SIG_SETMASK, &old_set, NULL);
Here, SIGINT is blocked during modification of counter.
```

### From user space application can you access (Read/write) signal mask present in your PCB?
```c
You can read/write the signal mask (in the process's PCB) using:

sigprocmask(SIG_BLOCK, ...)     // Block signals
sigprocmask(SIG_UNBLOCK, ...)   // Unblock
sigprocmask(SIG_SETMASK, ...)   // Replace
You cannot directly access the PCB, but these system calls interface with the kernel to update the signal mask
```
### Where is the process information present?
```c
In Linux, process info is stored in the kernel structure:
struct task_struct (this is the PCB)
It contains:
PID, state
Signal info
Scheduling info
Open files
Memory map
Viewable via:
    cat /proc/<pid>/status

```
### From userspace how do I access PCB information present in kernel space?
```c
You can’t access PCB directly, but you can read indirectly via:

/proc/<pid>/status
/proc/<pid>/stat
/proc/<pid>/maps
/proc/<pid>/cmdline
For deeper access:
Use ptrace(), or write a kernel module to expose internals.
```
### Can you create a proc virtual file system entry as user?
```c
No. Only kernel modules (written in C) can create /proc entries using proc_create().
From user space, you can read/write existing /proc files but can’t create new entries unless you have kernel code running.
```
### Without sending a signal can you invoke mysighand?
```c
You can directly call the signal handler function like any function
void mysighand(int sig) {
    printf("Handled signal: %d\n", sig);
}

int main() {
    mysighand(SIGUSR1);  // Manually call without signal
}
But this does not simulate real signal handling — it skips:

Kernel delivery
Signal mask behavior
Signal disposition logic
Use raise() or kill() for actual signal delivery.
```

                 MULTIPLE-CHOICE QUESTIONS (MCQs)

1.Which of the following best describes a signal in system programming?
A) A hardware interrupt generated by the CPU
B) A software interrupt delivered to a process
C) A system call for inter-process communication
D) A method for thread synchronization
```c
Ans : b

```
2. In a Unix-like operating system, what happens when a process receives a SIGSTOP signal?
A) The process terminates immediately.
B) The process is paused and can be resumed later.
C) The process is terminated, but its resources are not released.
D) The process is suspended until a SIGCONT signal is received.
```c
Ans: d
```
3. Which of the following statements about signal handling in multithreaded programs is true?
A) Each thread in a process has its own signal handler.
B) Signals can only be handled by the main thread of a process.
C) Signal handling behavior is undefined in multithreaded programs.
D) Signals are always delivered to the thread that created them.
```c
Ans: b
```
4. In signal handling, what does the SA_NODEFER flag indicate when used with the sigaction() function?
A) It specifies that the signal should not be blocked during its handler's execution.
B) It specifies that the signal should be delivered only once.
C) It specifies that the default action for the signal should be taken.
D) It specifies that the signal should be ignored.
```c
Ans: a
```
5. The SIGPIPE signal is sent to a process when:
A) It encounters an illegal instruction
B) It writes to a pipe with no one to read from it
C) It receives a termination request
D) It receives a segmentation fault
```c
Ans: b
```
6. Which signal is typically sent to a parent process when a child process terminates?
A) SIGTERM
B) SIGCHLD
C) SIGINT
D) SIGSEGV
```c
Ans:b
```

7. Which function is used to establish a signal handler for a specific signal in C programming?
A) signal()
B) sig action()
C) kill()
D) raise()
```c
Ans: a
```





